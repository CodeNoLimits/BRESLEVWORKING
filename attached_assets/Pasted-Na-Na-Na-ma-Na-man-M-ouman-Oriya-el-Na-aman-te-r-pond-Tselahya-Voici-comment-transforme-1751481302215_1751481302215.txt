Na Na·∏• Na·∏•ma Na·∏•man M√©ouman üïäÔ∏è

**Oriya‚Äôel Na‚Äôaman** te r√©pond, Tselahya !
Voici comment transformer ton appli Replit + Gemini pour qu‚Äôelle r√©ponde √† **toutes** les questions sur tous les livres de Rabb√©nou (‚ö†Ô∏è sauf *Likout√© halakhot*, comme demand√©).

---

## 1. Mat√©riel source : ce qu‚ÄôAbraham Ghezi doit pr√©parer

| √âtape               | D√©tails √† respecter                                                                                                      |
| ------------------- | ------------------------------------------------------------------------------------------------------------------------ |
| **1.1 Extraire**    | Un fichier **Word ou TXT par livre** (UTF-8) sans mise en forme exotique.                                                |
| **1.2 M√©tadonn√©es** | Nom du livre, chapitre, page / siman en **en-t√™te** des paragraphes, par ex. :<br>`@BOOK: Likout√© Moharan`<br>`@CHAP: 6` |
| **1.3 Exclure**     | Ne pas inclure *Likout√© halakhot* pour l‚Äôinstant.                                                                           |
| **1.4 D√©poser**     | Glisser les fichiers dans le dossier `/data/texts/` du repo avant ingestion.                                             |

---

## 2. Pipeline RAG ‚Äúmaison‚Äù (Replit friendly)

### 2.1 Vue d‚Äôensemble

1. **Ingestion ‚Üí vectorisation** des textes.
2. Stockage des **embeddings** dans une base **pgvector (Postgres) via Supabase** (*no-Firebase*).
3. **API `/ask`** :

   * Embed la question ‚Üí *search* les 5 chunks les plus proches.
   * Compose un prompt Gemini (cot√© serveur) : *question + contexte retrouv√©*.
   * Affiche r√©ponse + sources (livre / chapitre).

### 2.2 Choix technos

| Besoin        | Tech conseill√©e                                                     | Pourquoi                                              |
| ------------- | ------------------------------------------------------------------- | ----------------------------------------------------- |
| Embeddings    | `gemini-embedding-exp-03-07` ([ai.google.dev][1])                   | Mod√®le officiel, 768 dims, multilingue.               |
| Vector DB     | **Supabase** (Postgres + pgvector)                                  | 100 % open-source, facile sur Replit, pas de lock-in. |
| Orchestrateur | **LangChain-TS** ou **Google AI Edge RAG SDK** ([ai.google.dev][2]) | Libs pr√™tes pour Gemini + pgvector.                   |

---

## 3. Script d‚Äôingestion (Node / TypeScript)

```ts
// scripts/ingest.ts
import fs from "fs/promises";
import path from "path";
import { GoogleGenerativeAIEmbeddings } from "@langchain/google-genai";
import { SupabaseVectorStore } from "@langchain/community/vectorstores/supabase";
import { chunkText } from "./utils/chunkText";

const embeddings = new GoogleGenerativeAIEmbeddings({
  apiKey: process.env.GEMINI_API_KEY,
  modelName: "gemini-embedding-exp-03-07",
});

const supabase = await SupabaseVectorStore.initialize({
  url: process.env.SUPABASE_URL!,
  apiKey: process.env.SUPABASE_ANON_KEY!,
  tableName: "rabbi_texts",
  embeddings,
});

const files = await fs.readdir("./data/texts");
for (const file of files) {
  const raw = await fs.readFile(path.join("./data/texts", file), "utf8");
  const chunks = chunkText(raw, 1200, 200); // ~1200 tokens / chunk, 200 overlap
  await Promise.all(
    chunks.map(({ content, meta }) =>
      supabase.addDocuments([{ pageContent: content, metadata: meta }])
    )
  );
}
console.log("‚úì Ingestion termin√©e");
```

> **√Ä faire** : `npm i @langchain/google-genai @langchain/community pg supabase-js pgvector dotenv`.

---

## 4. Nouvelle route API dans Replit

```ts
// server/routes/ask.ts
import express from "express";
import { GoogleGenerativeAI } from "@google/generative-ai";
import { SupabaseVectorStore } from "@langchain/community/vectorstores/supabase";

const router = express.Router();
const genAI = new GoogleGenerativeAI({ apiKey: process.env.GEMINI_API_KEY });
const supabase = await SupabaseVectorStore.fromExistingIndex(/* same config */);

router.post("/", async (req, res) => {
  const { question } = req.body;
  // 1. Retrieve context
  const docs = await supabase.similaritySearch(question, 5);
  const context = docs.map(d => d.pageContent).join("\n---\n");
  // 2. Build prompt
  const prompt = `
Tu es un ma√Ætre qui r√©pond uniquement √† partir des √©crits de Rabbi Na'hman.
### CONTEXTE
${context}
### QUESTION
${question}
### R√âPONDS EN CITANT "Livre ‚Äì Chapitre ‚Äì ¬ß" quand possible.`;
  // 3. Gemini completion
  const model = genAI.getGenerativeModel({ model: "gemini-1.5-pro-latest" });
  const reply = await model.generateContent({ contents: [{ role: "user", parts: [{ text: prompt }] }] });
  res.json({ answer: reply.response.text() });
});

export default router;
```

Brancher la route dans `server/index.ts` : `app.use("/ask", askRouter);`.

---

## 5. D√©ploiement pas-√†-pas

1. **Secrets Replit** :

   * `GEMINI_API_KEY`, `SUPABASE_URL`, `SUPABASE_ANON_KEY`.
2. `npm install` les packages list√©s plus haut.
3. `npm run ingest` une fois (ou √† chaque nouvel ajout de livres).
4. `npm run dev` ‚Üí teste `POST /ask` dans l‚Äôonglet ‚ÄúWebview‚Äù ou Postman.
5. Ajoute un composant React ‚ÄúAskRabbeinu‚Äù qui POST la question et affiche la r√©ponse.

---

## 6. Am√©liorations possibles

| Option                    | Effet                                                                                              |
| ------------------------- | -------------------------------------------------------------------------------------------------- |
| **Streaming**             | Utilise `generateContentStream()` pour un effet *typewriter*.                                      |
| **Citations cliquables**  | Retourne aussi `docs[i].metadata` pour afficher ‚Äú‚Üí Likout√© M. 6:2‚Äù dans la r√©ponse.                |
| **Fallback Web Crawling** | Si la recherche locale n‚Äôa pas de match (score < 0.28), envoie la m√™me question √† l‚Äôagent crawler. |
| **Index incr√©mental**     | Surveille `/data/texts` : d√®s qu‚ÄôAbraham ajoute un livre ‚Üí re-ingest automatique via `fs.watch`.   |

---

## 7. Instruction Replit (README rapide)

````md
### Ajouter un nouveau livre
1. Glisser le fichier .docx ou .txt dans `/data/texts/`.
2. Ex√©cuter :
   ```bash
   npm run ingest
````

3. C‚Äôest tout : l‚ÄôAPI `/ask` le prend en compte imm√©diatement.

```

---

## 8. Pourquoi ce choix est stable

- **Pas de Firebase** : Supabase s‚Äôex√©cute m√™me en self-host (Docker).  
- Le **mod√®le d‚Äôembed officiel Gemini** est maintenu et optimis√© pour la recherche :contentReference[oaicite:2]{index=2}.  
- La **RAG SDK Google** montre la m√™me architecture (vector DB + Gemini) :contentReference[oaicite:3]{index=3}.  

---

### R√©sum√© express

1. **Collecte** des livres (Word ‚Üí TXT).  
2. **Script d‚Äôingestion** ‚Üí embeddings Gemini ‚Üí Supabase (pgvector).  
3. **Route `/ask`** : retrieval + Gemini completion.  
4. **React UI** : champ de question, affichage r√©ponse + source.  

Je reste pr√™t √† d√©tailler chaque ligne de commande ou √† corriger la moindre erreur de build. Dis-moi quand toi ou Abraham voulez passer √† l‚Äô√©tape suivante, et je te guide ‚Äúclic par clic‚Äù.

Na Na·∏• Na·∏•ma Na·∏•man M√©ouman üåü
::contentReference[oaicite:4]{index=4}
```

[1]: https://ai.google.dev/gemini-api/docs/embeddings?utm_source=chatgpt.com "Embeddings | Gemini API | Google AI for Developers"
[2]: https://ai.google.dev/edge/mediapipe/solutions/genai/rag?utm_source=chatgpt.com "AI Edge RAG guide - Gemini API"